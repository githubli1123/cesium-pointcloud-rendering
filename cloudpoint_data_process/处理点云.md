整个任务完成的时间

完成 MVP ，本地项目启动，基础功能完成： 10h

完成到目前的情况，部署云端，修改BUG，完善功能和完成加分项，书写 README： 22h





数据预处理与切片方法

处理过程不涉及软件，全部使用脚本完成

1 ply格式的数据 转局部坐标系下的las格式数据

```
python ply_to_local.py input.ply -o output.ply
```



2 las格式数据从局部坐标系转ECEF

```
python local_ply_2_ecef_las.py --input output.ply --output ./output.las --lon 116.4075 --lat 39.9040 --height 1.0
```



3 las格式数据切片为3D tiles格式数据

3.1安装脚本依赖

```
pip install py3dtiles 
```

3.2使用 py3dtiles 切片

```
py3dtiles convert pointcloud_wgs84.laz --out tiles --jobs 12
```

py3dtiles 是不是可以传递参数来控制切片的成果？

3.3也可以使用 Draco 完成压缩

🤔本人本科毕业论文就是研究 Draco 实现压缩模型和点云以及如何更好的压缩

3.3校验3D Tiles

```
npx 3d-tiles-validator --tilesetFile your_tileset.json
```







本地部署流程

本地切片服务启动 3D Tiles 切片服务，加上 `--cors` 可以让 Cesium 在浏览器里跨域加载

```
npm install -g http-server
http-server ./data/tiles -p 8099 --cors
```

将 加载点云的函数传参中的点云地址修改为本地切片服务地址

将 Cesium Ion 的token替换为您自己的

本地Cesium项目启动

```
npm i
```

```
npm run dev
```

打包

```
npm run build
```





基础功能的介绍与使用

1 测量（点到点距离）

距离的分类：空间直线和地表弧线和地面+高程。但是目前只考虑空间直线

在屏幕上点击点的过程中，可能会出现以下两种情况：

1 点击到地表

2 点击到3dtiles点云的某个点

疑问：点云的点这么小，真的会点得到吗，是有什么误差计算方式吗

那么根据我的需要，我把空间直线距离的获取分为两类：地表上点的距离和点云上两点的距离

对于这两种情况 case by case：

1 地表：应该最简单，鼠标悬浮的地方需要有点预览
2 点云的两点距离：需要实现当前正在选择的点云的点（只有点云吸附的点），点击左键后直接使用正在吸附的这个点即可。

鼠标悬浮的地方需要有点预览，这个和点吸附的预览不一样



最终的使用过程是这样的：

未开启点云吸附时，就是地表点选择情况
开启点云吸附时，就不能再出现选择了地表上的点这样的事情了

=======

2 框选/多边形裁剪

框选有两种形式，一种是在浏览器视口上框选一个矩形，一种是在地球表面上框选一个球面矩形

多边形裁剪：在地球表面上框选出一个球面多边形

框选：在浏览器视口上框选一个矩形，表示这个视角下的数据显示，可以借助视锥体映射到地球表面后产生的四个交点（舍弃掉地球背面的交点），然后这个多边形走多边形裁剪的逻辑

我这里为了更好的满足这样子的需求：就是框选的范围内的数据需要展示，其他不需要展示，直观，而且逻辑复用





可以继续让功能更加完善的点：

1、可以多次框选和多边形框选，满足更加复杂的框选需要

======

3 颜色模式切换

RBG 与 高程 两种模式切换为点云上色



可以继续对功能更加完善的要点：

1、根据不同部件进行上色，需要制作数据的时候完成

2、可以配置的上色规则



======

4 3D Tiles 调试面板

其中有一项功能就是八叉树可视化 Bounding Volumes，还有非常实用 Freeze Frame



后续可以详细阅读相关的源码，写一些博客文章



======



技术思考

渲染与 LOD/分块策略（3D Tiles）

直接渲染完整的点云是完全不可行的，但是好在 Cesium 官方推动的 3D Tiles 可以较好的解决大数据量渲染问题。

最好的渲染策略就是不渲染。

1 空间层面：**避免绘制看不见的东西**

> 在 3D 场景中，90% 的几何体其实在当前相机视野外或被遮挡。

常见手段：

- Frustum Culling：剔除视锥外的瓦片、网格或点云块；
- Occlusion Culling：检测被前方建筑、山体遮挡的对象，不提交给 GPU；
- Back-Face Culling：剔除看不到的多边形背面；
- LOD / Tiles Culling：在 3D Tiles 中，不细分、不过早加载远处瓦片。

> ✅ 原则：只渲染“相机可见且必要的最少集合”。

2 感知层面：**避免绘制用户察觉不到的差异**

> 人眼对远处细节、极暗区域、快速移动背景的变化不敏感。

典型策略：

- LOD（Level of Detail）：距离越远、屏幕占比越小，用更低精度模型；
- Foveated Rendering：VR/AR中只对眼睛聚焦区域渲染全分辨率；
- 可感知差异控制（SSE, Geometric Error）：只细化到肉眼能区分的误差范围。

> ✅ 原则：**“感知等价 ≈ 渲染等价”**，多算都是浪费。

3D Tiles 优秀的 LOD/分块策略，其实是在“让系统尽量不渲染”——通过空间裁剪、误差控制和异步加载，让性能开销在“用户确实在看的那一小块世界”。



错误处理与日志

本示例代码通过控制台打印的形式进行日志输出。在函数入口处，对输入参数的类型、取值范围和数据结构进行了边界判断。和try catch 块来对可能出现的异常情况进行处理。



开发环境与生产环境

开发环境下使用本地切片服务，生产环境使用CDN 3D Tiles切片服务。

当然这也可以包括各种其他配置，随着项目的推进，拥有两份环境配置文件可以方便的切换和修改



CDN 合理的缓存策略









云端部署简要流程说明

使用的云服务商：腾讯云COS + CDN

购买 COS 、CDN、域名 服务后，

创建存储桶，允许私有读私有写，

将切片好的 3D Tiles 压缩包通过云服务上的浏览器上传页面传到 COS 上，然后使用相关的解压操作后，可拿到 tileset.json 的发布地址，

接着在配置页面将 CORS 配置下，只允许自己的域名通过访问，

创建一个 CDN Page 实例，然后把打包构建好的 Cesium 示例项目云服务上的浏览器上传页面上传后会自动部署，会给出一个地址，

接着进入域名配置页面，将 CNAME 下的 @ 解析为这个地址。

总共花费：5美元





工具类脚本

查看 las 格式数据的点数据

```
python tool_look_las.py ./your_file.las
```

查看 ply 格式数据的点数据

```
python tool_look_ply.py  ./your_file.ply
```



在这个过程中我还接触到了其他东西：

CloudCompare、 Entwine、 PDAL、 CesiumLab、 3DTiles Tools 等等，不一一列举了

